#!/bin/bash

#
# WIP - me trying to get a better handle on the workings of the major
#       init systems.
#

fatal() {
  printf >&2 "\033[1;37;41m[FATAL]:\033[0m "
  [[ -n "$1" ]] && printf >&2 "%s" "$1" || printf >&2 "Unrecoverable error."
  printf >&2 "\n"
  exit "${2:-1}"
}

get_initctl_path() {
  local initctl initctl_path
  for initctl in launchctl systemctl initctl service; do
    initctl_path="$(type -P "${initctl}")"
    if [[ -x "${initctl_path}" ]]; then
      printf "${initctl_path}"
      return
    fi
  done
}

find_config_path() {
  find "$1" -name "$2" -print 2>/dev/null | head -n 1
}

get_initctl_config_path() {
  local path_name_pair config_path unit_type
  local -a pair
  # launchd, then systemd, then upstart
  for path_name_pair in \
    "/System/Library/LaunchDaemons;$1.plist"  \
    "/System/Library/LaunchAgents;$1.plist"   \
    "/Library/LaunchDaemons;$1.plist"         \
    "/Library/LaunchAgents;$1.plist"          \
    "${HOME}/Library/LaunchAgents;$1.plist"   \
                                              \
    "/etc/systemd/system;$1"                  \
    "/run/systemd/system;$1"                  \
    "/usr/lib/systemd/system;$1"              \
    "${XDG_CONFIG_HOME}/systemd/user;$1"      \
    "${HOME}/.config/systemd/user;$1"         \
    "/etc/systemd/user;$1"                    \
    "${XDG_RUNTIME_DIR}/systemd/user;$1"      \
    "/run/systemd/user;$1"                    \
    "${XDG_DATA_HOME}/systemd/user;$1"        \
    "${HOME}/.local/share/systemd/user;$1"    \
    "/usr/lib/systemd/user;$1"                \
                                              \
    "/etc/init;$1.conf"                       \
    "${HOME}/.init;$1.conf"
  do
    IFS=';' read -ra pair <<<"${path_name_pair}"

    config_path="$(find_config_path "${pair[0]}" "${pair[1]}")"
    if [[ -e "${config_path}" ]]; then
      printf "${config_path}"
      return
    fi

    if [[ "${pair[0]}" = */systemd/* ]]; then
      for unit_type in service socket device mount automount swap \
                       target path timer slice scope
      do
        config_path="$(find_config_path "${pair[0]}" "${pair[1]}.${unit_type}")"
        if [[ -e "${config_path}" ]]; then
          printf "${config_path}"
          return
        fi
      done
    fi
  done
}

get_initscript_path() {
  local initscript_path
  for initscript_path in \
    "/etc/init.d/$1"      \
    "/etc/init.d/rc.d/$1" \
    "/etc/rc.d/$1"
  do
    if sudo test -x "${initscript_path}"; then
      printf "${initscript_path}"
      return
    fi
  done
}

initctl() {
  [[ "$3" = "${HOME}"* ]] && local sudo_cmd="sudo"
  local initctl_config_file="$(basename "$3")"
  local service_name="${initctl_config_file%.*}"
  local initctl_type="$(basename "$1")"

  case "${initctl_type}" in
    launchctl)
      case "$2" in
        start)
          "${sudo_cmd}" "$1" load -F "$3"
          ;;
        stop)
          "${sudo_cmd}" "$1" unload -F "$3"
          ;;
        restart)
          "${sudo_cmd}" "$1" unload -F "$3"
          "${sudo_cmd}" "$1" load -F "$3"
          ;;
      esac
      ;;
    initctl)
      "${sudo_cmd}" "$1" "$2" "${service_name}"
      ;;
    systemctl)
      "${sudo_cmd}" "$1" "$2" "${initctl_config_file}"
      ;;
    service)
      "${sudo_cmd}" "$1" "${service_name}" "$2"
      ;;
  esac
}

print_usage() {
  printf >&2 "Usage: $(basename "$0") <action> <service>\n"
}

main() {
  export PATH="/usr/bin:/bin:/usr/local/bin:/usr/sbin:/sbin:/usr/local/sbin"

  local initctl_path="$(get_initctl_path)"
  local initctl_config_path="$(get_initctl_config_path "$2")"
  local initscript_path="$(get_initscript_path "$2")"

  if [[ -n "${initctl_path}" && -n "${initctl_config_path}" ]]; then
    initctl "${initctl_path}" "$1" "${initctl_config_path}"
  elif [[ -n "${initscript_path}" ]]; then
    sudo "${initscript_path}" "$1"
  else
    fatal "Couldn't find a way to control ${2}."
  fi
}

for arg; do
  if [[ "${arg}" = "-h" || "${arg}" = "--help" ]]; then
    print_usage
    exit
  fi
done

if [[ "$#" -ge "2" ]]; then
  main "$@"
else
  print_usage
  exit 1
fi
