#!/usr/bin/env ruby

require 'fileutils'
require 'tempfile'
require 'erb'

DCP_PATH = File.join(ENV['HOME'], '.dcp')
CONF_PATH = File.join(DCP_PATH, 'conf', 'wp-site')
WP_TMPL_PATH = File.join(DCP_PATH, 'misc', 'wp-config.php.erb')
NGX_TMPL_PATH = File.join(DCP_PATH, 'misc', 'php-site.conf.erb')
INITCTL_PATH = File.join(DCP_PATH, 'bin', 'dcp-initctl')
WORDPRESS_URL = 'https://wordpress.org/latest.tar.gz'

ENV['BUNDLE_GEMFILE'] = File.join(DCP_PATH, 'Gemfile')
require 'bundler/setup'
require 'dotenv'
require 'fog'

def handle_exit
  if $?.exitstatus == 0
    yield
  else
    $stderr.puts "\nError: PID #{$?.pid} exited non-zero."
    exit 1
  end
end

def make_record(zone, options = {})
  record = zone.records.new(options.merge({ ttl: 600, }))
  $stderr.print "Configuring DNSimple #{options[:type]} record..."
  record.save
  $stderr.puts(record.persisted? ? ' Done.' : ' Failed.')
  record
end

begin
  Dotenv.load!(CONF_PATH)
rescue Errno::ENOENT
  $stderr.puts "Error: configuration file (#{CONF_PATH}) does not exist!"
  exit 1
end

unless ARGV.count > 0
  $stderr.puts "Error: must specify a domain name to set up."
  exit 1
end
unless ENV['MYSQL_USERNAME'] && ENV['MYSQL_PASSWORD']
  $stderr.puts "Error: MySQL credentials must be in #{CONF_PATH} as MYSQL_USERNAME and MYSQL_PASSWORD."
  exit 1
end
unless ENV['DNSIMPLE_EMAIL'] && ENV['DNSIMPLE_TOKEN'] && ENV['SERVER_IP']
  $stderr.puts "Error: DNSimple API credentials and an IP address for this machine must be in #{CONF_PATH} as DNSIMPLE_EMAIL, DNSIMPLE_TOKEN, and SERVER_IP."
  exit 1
end
unless ENV['NGX_CONF_DIR']
  $stderr.puts "Error: nginx configuration directory must be in #{CONF_PATH} as NGX_CONF_DIR."
  exit 1
end

domain = ARGV.first.gsub(/https?:\/\//, '').split('/').first
domain_tokens = domain.split('.')
if domain_tokens.length == 2
  subdomain = false
  domain_name = domain_tokens[0]
  tld = domain_tokens[1]

  server_domain = "#{domain_name}.#{tld}"
  redirect_domain = "www.#{domain_name}.#{tld}"
elsif domain_tokens.length == 3
  subdomain = domain_tokens[0]
  domain_name = domain_tokens[1]
  tld = domain_tokens[2]

  server_domain = "#{subdomain}.#{domain_name}.#{tld}"
  redirect_domain = subdomain == 'www' ? "#{domain_name}.#{tld}" : false
else
  $stderr.puts "Error: invalid domain name."
  exit 1
end
dnsimple_domain = "#{domain_name}.#{tld}"
if subdomain && subdomain != 'www'
  friendly_name = "#{subdomain}_#{domain_name}"
else
  friendly_name = domain_name
end

old_wd = Dir.pwd
Dir.chdir(ENV['HOME'])

$stderr.print 'Downloading WordPress...'
`curl --silent --location --remote-name #{WORDPRESS_URL}`
handle_exit { $stderr.puts ' Done.' }

$stderr.print 'Extracting WordPress...'
`tar -xzf #{File.basename(WORDPRESS_URL)}`
handle_exit { $stderr.puts ' Done.' }
FileUtils.rm_f(File.basename(WORDPRESS_URL))

FileUtils.mv('wordpress', friendly_name)
wp_path = File.join(ENV['HOME'], friendly_name)
Dir.chdir(old_wd)

$stderr.print 'Creating database...'
`mysqladmin -u #{ENV['MYSQL_USERNAME']} -p#{ENV['MYSQL_PASSWORD']} create #{friendly_name}`
handle_exit { $stderr.puts ' Done.' }

$stderr.print 'Configuring WordPress... '
wp_tmpl = ERB.new(File.read(WP_TMPL_PATH)).result(binding)
File.open(File.join(wp_path, 'wp-config.php'), 'w') do |f|
  f.write(wp_tmpl)
end
$stderr.puts 'Done.'

dnsimple = Fog::DNS.new(
  provider: 'DNSimple',
  dnsimple_email: ENV['DNSIMPLE_EMAIL'],
  dnsimple_token: ENV['DNSIMPLE_TOKEN'],
)
zone = dnsimple.zones.all.select { |z| z.domain == dnsimple_domain }
if zone.empty?
  $stderr.puts 'Error: requested domain is not on the specified DNSimple account!'
  exit 1
end
zone = zone.first

if subdomain && subdomain != 'www'
  make_record(zone, type: 'A', name: subdomain, value: ENV['SERVER_IP'])
else
  make_record(zone, type: 'A', name: '', value: ENV['SERVER_IP'])
  make_record(zone, type: 'CNAME', name: 'www', value: dnsimple_domain)
end

$stderr.puts 'Configuring server (you may be prompted for your password)...'
ngx_conf_path = File.join(ENV['NGX_CONF_DIR'], "#{friendly_name}#{ENV['NGX_CONF_EXT']}")
ngx_tmpl = ERB.new(File.read(NGX_TMPL_PATH), nil, '<>').result(binding)

tf = Tempfile.new(friendly_name)
begin
  tf.write(ngx_tmpl)
  tf.flush
  tf.close

  system("sudo cp #{tf.path} #{ngx_conf_path}")
  system("sudo chown root:root #{ngx_conf_path}")
  system("sudo chmod 644 #{ngx_conf_path}")
  system("#{INITCTL_PATH} restart nginx")
ensure
  tf.unlink
end
$stderr.puts 'Done.'
